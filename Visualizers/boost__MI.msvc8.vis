;----------------------------------------------------
; BOOST_VISUALIZER_START boost::multi_index_container
;
; Copyright Filip Konvièka 2007 - 2009. Use, modification and distribution are subject
; to the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt
; or copy at http://www.boost.org/LICENSE_1_0.txt)
;
; @guid     CA3A7EDA-43F3-11DC-9D06-4B5856D89593
; @platform msvc-8, msvc-9
; @version  2.0
; @header   mic_visualizer.hpp
; @author   Filip Konvièka
; @email    filip dot konvicka at logis dot cz
;
; Usage
; =====
;
; This version is for Boost.MultiIndex versions 1.35 and above.
; The other version of this file is known to work for Boost.MultiIndex 1.34.1.
;
; Visualization must be explicitly enabled in the code for each type.
; For each multi_index_container type, you need to call
;
;   VISUALIZE_MULTI_INDEX_CONTAINER(TypeName);
;
; at global namespace level. The macro is defined in the accompanying header file mic_visualizer.hpp.
;
;
;------------------------------------
; boost::multi_index_container - base
;
; This passes control to the header_holder decoders :-)
boost::multi_index::multi_index_container<*,*,*>{
  preview(#($c.node_count, " items (multi_index_container)"))
  children(
    #(
      data:((msvc_helpers::multi_index_helper_2<boost::multi_index::multi_index_container<$T1,$T2,$T3> >*)&$c)->header,
      original members: [$c,!]
    )
  )
}
;-----------------------------------------------
; boost::multi_index_container - sequenced index
boost::multi_index::detail::header_holder<boost::multi_index::detail::sequenced_index_node<*>*,*>{
  preview(#("sequenced index"))
  children(
    #(
      #list(
            head : *(((boost::multi_index::detail::sequenced_index_node_trampoline<$T1>*)($c.member))->next_),
            size : (($T3*)&$c)->node_count,
            next : next_
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::sequenced_index_node<$T1> >*)(boost::multi_index::detail::sequenced_index_node<$T1>*)(boost::multi_index::detail::sequenced_index_node_trampoline<$T1>*)(&$e))->value
    )
  )
}
;---------------------------------------------------
; boost::multi_index_container - random access index
boost::multi_index::detail::header_holder<boost::multi_index::detail::random_access_index_node<*>*,*>{
  preview(#("random access index"))
  children(
    #(
      #array(
          expr:  (($T3*)&$c)->ptrs.spc.data_[$i],
          size:  (($T3*)&$c)->node_count
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::random_access_index_node<$T1> >*)(boost::multi_index::detail::random_access_index_node<$T1>*)(boost::multi_index::detail::random_access_index_node_trampoline<$T1>*)(&$e))->value
    )
  )
}
;--------------------------------------------
; boost::multi_index_container - hashed index
; NOTE: it seems that we don't need to retrieve the actual allocator used, std::allocator will suffice...
boost::multi_index::detail::header_holder<boost::multi_index::detail::hashed_index_node<*>*,*>{
  preview(#("hashed index - ", (($T3*)&$c)->node_count, " in ", (($T3*)&$c)->buckets.size_, " buckets"))
  children(
    #(
      #array(
            expr : (($T3*)&$c)->buckets.spc.data_[$i],
            size : (($T3*)&$c)->buckets.size_
      ) : *(msvc_helpers::multi_index_helper_3<boost::multi_index::detail::hashed_index_node<$T1> >*)(void*)&$e
    )
  )
}
msvc_helpers::multi_index_helper_3<boost::multi_index::detail::hashed_index_node<*> >{
  preview(#if ( ((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)->next_==((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c) )
             ; no data at all
             (#("---"))
          #else (
             #if ( ((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)->next_->next_==((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c) ) (
               ; 1 item: preview as _value_
               #( ((msvc_helpers::multi_index_helper<boost::multi_index::detail::hashed_index_node<$T1> >*)(boost::multi_index::detail::hashed_index_node<$T1>*)(boost::multi_index::detail::hashed_index_node_trampoline<$T1>*)(((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)->next_))->value)
             ) #else (
               ; multiple items: preview as [_value_ ...]
               #("[", ((msvc_helpers::multi_index_helper<boost::multi_index::detail::hashed_index_node<$T1> >*)(boost::multi_index::detail::hashed_index_node<$T1>*)(boost::multi_index::detail::hashed_index_node_trampoline<$T1>*)(((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)->next_))->value, " ...]")
             )
          )
         )
  children(
    #(
      ; multiple items: view as list
      #list(
        head: ((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)->next_,
        next: next_,
        skip: ((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::hashed_index_node<$T1> >*)(boost::multi_index::detail::hashed_index_node<$T1>*)(boost::multi_index::detail::hashed_index_node_trampoline<$T1>*)(&$e))->value
    )
  )
}
;---------------------------------------------
; boost::multi_index_container - ordered index
; NOTE: it seems that we don't need to retrieve the actual allocator used, std::allocator will suffice...
boost::multi_index::detail::header_holder<boost::multi_index::detail::ordered_index_node<*>*,*>{
  preview(#("ordered index"))
  children(
      #tree(
            head : *(boost::multi_index::detail::ordered_index_node_compressed_base<std::allocator<char> >*)(boost::multi_index::detail::ordered_index_node_impl<std::allocator<char> >*)(void*)(((boost::multi_index::detail::ordered_index_node_trampoline<$T1>*)($c.member))->parentcolor_&~1U),
            size : (($T3*)&$c)->node_count,
            left : left_,
            right : right_,
            skip : 0
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::ordered_index_node<$T1> >*)(boost::multi_index::detail::ordered_index_node<$T1>*)(boost::multi_index::detail::ordered_index_node_trampoline<$T1>*)(&$e))->value
  )
}
;
; BOOST_VISUALIZER_END boost::multi_index_container
;--------------------------------------------------
